[{"title":"","date":"2017-05-06T03:58:50.992Z","path":"2017/05/06/django/","text":"django文档url视图调度器url调度器初级url调度器中级url调度器高级 settings.py配置文件 ALLOWED_HOSTS，允许访问的域名 MIDDLEWARE_CLASSES,注册中间件，要按顺序,request从上到下，response从下到上 DATAVASES，数据库配置","tags":[]},{"title":"","date":"2017-05-06T03:58:50.992Z","path":"2017/05/06/flask/","text":"记录学习flask的知识 itsdangerous1.签名接口123456from itsdangerous import Signers = Singer('secret-key')&gt;&gt; s.sign('my string')&gt; 'my string.wh6tMHxLgJqB6oY1uT73iMlyrOA'&gt;&gt; s.unsign('my string.wh6tMHxLgJqB6oY1uT73iMlyrOA')&gt; 'my string' 2.使用时间戳签名 时间戳签名可以过期。反签名的时候可以验证有没有过期1234from itsdangerous import TimestampSigners = TimestampSigner('secret-key')string = s.sign('foo')s.unsign(string, max_age = 5) 3.序列化 因为字符串难以处理，本模块也提供了一个与json123456from itsdangerous import Serializers = Serializer('secret-key')s.dumps([1,2,3,4])&gt;&gt; '[1, 2, 3, 4].r7R9RhGgDPvvWl3iNzLuIIfELmo's.loads('[1, 2, 3, 4].r7R9RhGgDPvvWl3iNzLuIIfELmo')&gt;&gt; [1,2,3,4] 4.URL安全序列化 如果能够向只有字符受限的环境中传递可信的字符串的话，将十分有用123456from itsdangerous import URLSafeSerializers = URLSafeSerializer('secret-key')s.dumps([1,2,3,4])&gt;&gt; 'WzEsMiwzLDRd.wSPHqC0gR7VUqivlSukJ0IeTDgo's.loads('WzEsMiwzLDRd.wSPHqC0gR7VUqivlSukJ0IeTDgo')&gt;&gt; [1,2,3,4] 5.JSON WEB签名12345from itsdangerous import JSONWebSignatureSerializers = JSONWebSignatureSerializer('secret-key')s.dumps(&#123;'x':42&#125;)&gt;&gt; 'eyJhbGciOiJIUzI1NiJ9.eyJ4Ijo0Mn0.ZdTn1YyGz9Yx5B5wNpWRL221G1WpVE5fPCPKNuc6UAo's.loads('eyJhbGciOiJIUzI1NiJ9.eyJ4Ijo0Mn0.ZdTn1YyGz9Yx5B5wNpWRL221G1WpVE5fPCPKNuc6UAo')","tags":[]},{"title":"高质量python编程读书笔记","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/high_quality_python/","text":"高质量python编程读书笔记利用assert来发现问题 assert expression1 , expression2123x = 1y = 2assert x == y, \"not equals\" 数据交换不使用中间值 x,y = y,x 不推荐使用type来进行类型检查 python可以使用type来检查类型，例如123import typesprint type(n) is types.IntType 尽量转换为浮点类型后再做除法eval安全漏洞 eval可以将字符串当作表达式来运算，但是表达式存在安全漏洞，如果源不是可信任的情况下，不使用eval。在需要使用eval的情况下用更安全的ast.literal_eval()代替，literal_eval()可以会检测是不少合法的python类型，是的话才执行 enumerate() 尽量使用enumerate 考虑兼容性问题尽量使用unicodesssss","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]},{"title":"linux command","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/linux_command/","text":"Linux指令创建符号链接硬链接 硬链接是一个文件名，创建指令。硬链接有一个计数器，没删除一个硬链接，计数器减1,当计数器归0的时候，删除文件。1&gt;&gt;ln fun fun-hard 软链接 软链接类似于一个指针，可以只向文件和文件夹，硬链接不能指向文件夹1&gt;&gt; ln -s fun fun-soft 移除文件和目录type 显示执行命令的指令类型1&gt;&gt; type ls which 显示可执行文件位置，而不响应内置命令和命令别名(可执行程序代替物)1&gt;&gt;which ls help 显示指令的使用信息1&gt;&gt; mkdir --help man 显示程序手册页12&gt;&gt;man ls&gt;&gt; man 5 ls","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]},{"title":"effective python笔记","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/effective-python/","text":"类与继承多用public属性，少用private属性 对于python的类来说，其属性可见度只有两种，即public和private。以两个下划线开头的属性是private字段(private字段，开头至少有两个下划线，结尾最多一个下划线)。 举个例子123456class myobject(): def __init__(self): self.__private_ = 1me = myobject()print me.__private_ 这个时候会报错，如果要访问_private属性，要通过类里的方法来访问。还有一点要注意，继承这个类的子类是无法访问private属性的。 下面来谈一下private属性的原理，当Python解释器遇到类似__private_属性时会自动做一个替换，把__private_替换为_myobject__private_,然后通过这个名字来访问。所以如果直接访问__private_会导致错误发生。 根据这一原理，我们可以直接访问_myobject__private_，这样就不再受制于private属性的访问权限，可以在子类、外部来访问。 根据上面的介绍，我们可以知道python解释器实际上是无法严格限制对private属性的访问。所以为了尽量减少对private属性访问所带来的错误，我们最好都遵守通用规范来书写。类部私有的方法和属性的名字前面加一个_来表示，例如：_private，这样当你在子类或外部类来访问时应该慎重。 只有一种情况优先使用private属性，当超类里的变量是频繁被访问的，且子类不受你的控制。那么这个时候，子类与发类的重命名所带来的错误，应该使用private属性。 colletions.abc的运用 python作为OO语言，在实际开发中我们大多数工作都是在进行类的编写。我们可以编写类，将数据对象之间交互方式封装在类中，从而定义自己的数据结构。但是想完美的定义一种数据结构并非简单的事。举个粒子：123456789class example(list): def __init__(self): super(example,self).__init__() def frequency(self): counts = &#123;&#125; for item in self: counts.setdefault(item,0) counts[item] += 1 return counts 这里我们定义了一种列表的frequency方法。然而只实现这种方法是不够的，我们还需要定义__len__()方法，来获取列表长度。为了避免忘掉编写某个方法的麻烦，可以使用colletions.abc。请看下面粒子： 1234from colletions.abc import Sequenceclass example(Sequence): passfoo = example() 运行程序，这个时候会报错 我们让子类继承Sequence这个抽象类，如果子类没有实现Sequence这个抽象类里方法，就会提示运行错误，这样就能避免忘记实现数据结构中的某种方法 #元类及属性 用纯属性取代get和set方法 在其他编程语言中，我们要对类中的属性进行操作时，需要手工实现setter和getter的方法，但是在Python中我们有更方便的方法来进行属性的操作。请看下面粒子:123456789101112131415161718class example(object): def __init__(self): self.test1 = 1 @property def test(self): return self.test1 @test.setter def test(self, value): self.test1 = valueexm = example()exm.test&gt;&gt; 0exm.test = 3exm.test&gt;&gt; 3 当我们调用property装饰器的时候，它会自动生成@test.setter装饰器。这样就能很放便的进行get和set操作而不需要编写set和get函数。 用描述符来改写需要复用的property方法 前面通过property方法来设置属性，但是property设置属性有一个缺陷就是无法复用。这就意味着，如果有许多相似的功能时，我们需要重复的编写@property，这就造成了很多重复的工作。这个时候我们可以考虑使用__set__和__get__属性。 下面讲解一下__set__和__get__的具体用法:12345678910111213class Celsius(object): def __init__(self, value = 0.0): self.value = float(value) def __get__(self, instance, owner): return self.value def __set__(self, instance, value): return self.value = float(value)class Temperature(object): celsius1 = Celsius() celsius2 = Celsius()temp = Temperature() 如果一个类中定义类__set__和__get__方法我们就称这个类为descriptors。instance表示类的实例，在这里指temp。owner表示类，这里指Temperature。1temp.celsius1 = 1 现在我们就能很方便对属性进行赋值了。但要注意一个问题celsius1和celsius2指向同一个实例。因为在Temperature初始化的过程中，Celsius只会初始化一次。 为了解决这种问题，我们可以创建一个字典，来保存不同的状态。 123456789class Celsius(object): def __init__(self): self._value = &#123;&#125; def __get__(self, instance, owner): if instance is None: return self._value.get(instance, 0) def __set__(self, instance, value): if instance is not None: self._value[instance] = value 这样就能保存不同实例的状态。但这种做法会造成内存泄漏 - -!。为什么会造成内存泄漏，我也没有研究清楚。 __getattr__, __setattr__和__getattribute__按需生成属性 前面介绍的设置属性的方法都是需要提前设置好属性，如果我们想要动态的设置属性就需要用到__getattr__, __setatrr__和__getattribute__等方法。 看下面的例子1234567class lazyDB(object): def __init__(self): self.exists = 5 def __getattr__(self, name): value = 'value for %s' % name setattr(self, name, value) return value 这里定义了一个类，当我们对lazyDB设置属性的时候，python会自动在lazyDB的生成实例字典中去寻找，如果没有找到则会调用__getattr__方法。这个时候我们可以用setattr方法将属性设置下去。一旦设置下去了，下一次调用该属性时，就能直接找__dict__里面找到，就不会再次调用__getattr__方法。 而对于__getattribute__和__setattr__属性，他们不管是直接函数调用还是普通属性赋值都会触string发。其中注意12def __setattr__(self,name,value): super(xx, self).__setattr__(self, name ,value) 这里注意，一定要用super否则会出现无限递归!! 使用subprocess来控制进程 我们可以使用subprocess来对子进程进行管理，下面讲解一下subprocess的用法:subprocess.call(*args, stdin = None, stdout = None, stderr = None, shell = False) subprocess.call的*args参数可以接受一个列表，列表里面为执行指令的命令。如下例所示:subprocess.call([&#39;ls&#39;, &#39;-l&#39;])但是它只能接受一些最常用的命令，如果是复杂的指令应该使用Popen()方法。 subprocess.check_output(*args, stdin = None, stdout = None, stderr = None, shell = False) check_output方法与call方法类似，但是它只能输出字符串。subprocess.check_output(&quot;exit 1&quot;, shell = True)如果是类似于这种执行指令，那么会报错。 subprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0) Popen的args用法与上面的类似123import shlex, subprocesscommand_line = raw_input()args = shlex.split(command_line) 这里说明一下stdin,sdtout和stderr的用法。如果参数为空，则表明子进程不会额外有新的管道而是继承父进程的文件句柄。可选参数为subprocess.PIPE，可以用来表示一个文件句柄，一个文件对象。123456789def run_openssl(data): env = os.environ.copy() en['password'] = '......' proc = subprocess.Popen(['openssl', 'enc', '-desc3', '-pass', 'env:password'], env = env, stdin = subprocess.PIPE stdout = subprocess.PIPE) proc.stdin.write(data) proc.stdin.flush() Popen.poll() 这个方法用来检查子进程是否已经终止Popen.wait() 这个方法等待子进程终止Popen.communicate(input = None) 这个方法可以与子进程进行交互，从stdin输入数据，stdout获得输出的数据。Popen.terminate() 停止子进程Popen.kill() 杀死子进程 使用Queue来协调线程工作 开发过程中，我们经常需要协调实务，在各种协调方式中，我们通常使用函数管线。函数管线的作用类似于工厂中的流水线。一个东西要一部分完成了再进行下一部分。如果我们使用列表来作为管道会遇到下面的问题: 每个阶段的工作函数，其执行速度可能有差别，这就使前一阶段可能会拖慢后一阶段的进度，从而令整个管道延迟。前一阶段的任务如果迟迟没有完成，那么后一阶段将会陷入饥饿，浪费运算。 还有如果某一阶段的任务处理较慢，那么前面阶段将会堆积，可能造成内存耗尽从而崩溃。 我们可以使用内置的Queue类来解决这个问题。请看下面例子:1234567from queue import Queuequeue = Queue()def consumer(): print（'Consumer waiting') queue.get() print('Consumer done') 当queue.get()这个方法被调用的时候，如果队列为空线程在这里会被阻塞，直到queue.put()加入新的事务到队列里面。这样就无需查询队列的状态。同时我们还能指定内存的状态，这样能防止超出内存限制。例如，queue = Queue(1)，我们还可以使用queue.task_done()来判断管道中的任务是否处理完毕。同时可以继承Queue来重构。12345678910111213141516class ClosableQueue(Queue): SENTINEL = object() def close(self): self.put(self.SENTINEL) def __iter__(self): while True: item = self.get() try: if item is self.SENTINEL: return yield item finally: self.task_done() 使用协程来模拟并发 前面使用线程来实现的并发的方式，但多线程存在维护难度大，切换开销大等缺点。我们可以使用协程来实现并发。12345678def my_coroutine(): received = yield 3 print ('received', received)it = my_coroutine()value = next(it) # or it.next()it.send(\"first\")it.send(\"second\") 程序开始运行的时候，当运行到value = next(it)的时候，线程会在这里会被阻塞，切换到received = yield 3。这里yield会给received返回一个值。当调用send的时候，会将send的值赋给received，并继续运行。这样就能实现并发执行程序。注意一点，send or next，都只执行到下一个yield。","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]},{"title":"cookbook","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/python-cookbook/","text":"让带有N个参数的可调用对象以较少的参数形式调用 看下面的例子12345678910111213141516171819def output_result(result, log = None): if log is not None: log.debug('Got: %r', result)def add(x, y): return x+yif __nam__== '__main__': import logging from multiprocessing import Pool from functools import partial logging.basicConfig(level = logging.DEBUG) log = logging.getLogger('test') p = Pool() p.apply_async(add, (3, 4), callback = partial(output_result, log = log)) p.close() p.join() 用函数替代只有单个方法的类 先看一个类的例子 12345678910from urllib.request import urlopenclass UrlTemplate: def __init__(self, template): self.template = template def open(self, **kwargs): return urlopen(self.template.format_map(kwargs))yahoo = UrlTemplate('xxxxx')for line in yahoo.open(names = 'IBM,APPL,FB', fields = 'sl1c1v'): print (line.decode('utf-8')) 可以用一个闭包函数来取代,使用类的原因主要是因为需要保存template变量，但是对于这种只有一个方法的类，我们使用闭包函数更加优雅。 12345678def Urltemplate(template): def opener(**kwargs): return urlopen(template.format_map(kwargs)) return openeryahoo = Urltemplate('xxxxxx')for line in yahoo(names = 'IBM, AAPL, FB', fields = 'c11c1v') print (line.decode('utf-8')) 在回调函数中携带额外的状态 用类来携带额外状态 123456789class ResultHandler: def __init__(self): self.sequence = 0 def handler(self, result): self.sequence += 1 print ('xxx')r = ResultHandler()apply_async(add, (2, 3), callback = r.handler) 用闭包来携带额外的状态,这里用了Python3新增加的nonlocal关键字，可以使用外部变量 1234567def make_handler(): sequence = 0 def handler(result): nonlocal sequence sequence += 1 print ('xxxx') return handler 访问定义在闭包内的变量123456789def sample(): n = 0 def func(): print ('n = ', n) def get_n(): return n def set_n(value): nonlocal n n = value nonlocal关键字是访问并修改上一级代码块的变量,global关键字是访问修改全局变量.单纯的引用不需要声明关键字.","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]},{"title":"mysql","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/mysql/","text":"mysql数据库操作指令连接指令12345mysql -h localhost -u root -p123(MySQL 连接本地数据库，用户名为“root”，密码“123”（注意：“-p”和“123” 之间不能有空格）)mysql -h 172.16.16.45 -P 3306 -u root -p123(MySQL 连接远程数据库（192.168.0.201），端口“3306”，用户名为“root”，密码“123”)mysql -h localhost -u root -p(MySQL 连接本地数据库，用户名为“root”，隐藏密码) mysql权限管理MYSQL权限管理 mysql数据类型MYSQL数据类型 操作与修改表 MYSQL自增特性ALTER TABLE person MODIFY person_id SMALLINT UNSIGNED AUTO_INCREMENT 插入语句 123INSERT INTO person(person_id, fname,lname,gender,birth_data)VALUES(null, 'William', 'Turner', 'M', '1972-05-27') 查询语句 123SELECT person_id,fname,lname,birth_dataFROM personWHERE person_id = 1; 1234SELECT foodFROM favorite_foodWHERE person_id = 1ORDER BY food; 更新数据 1234567UPDATE personSET street = '1225 Tremont St.', city = 'Boston', state = 'MA', country = 'USA', postal_code = '02138'WHERE person_id = 1; 显示数据库中的表SHOW TABLES; 删除数据库中的表DROP TABLE person 查询操作 SELECT子句 SELECT子句用于在所有可能的列中，选择查询结果集包含哪些列。可以包含下面的信息 字符，比如数字或字符串 表达式 调用内建函数 用户自定义的函数调用12SELECT *FROM department; 列的别名 12345SELECT emp_id, 'ACTIVE' AS status, emp_id * 3.14 AS empid_x_pi, UPPER(lname) AS last_name_upperFROM employee; 去除重复行 12SELECT DISTINCT cust_idFROM account; sqlalchemy的使用 这部分通过例子直接看怎么用，要快一点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from sqlalchemy import create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String,Table, MetaDataDB_CONNECT_STRING = 'mysql://root:2316678@localhost/test?charset=utf8'#python3不支持mysqldb,用pymysql#链接数据库的url，mysql是要链接的数据库，root是用户名，2316678是密码，localhost是ip，test链接的数据库（可省略），charset是utf-8编码格式engine = create_engine(DB_CONNECT_STRING, echo = True)#创建引擎DB_seesion = sessionmaker(bind = engine)#链接数据库的会话session = DB_seesion()#会话实例化Base = declarative_base()#sqlalchemy的Base实例meta = MetaData(engine)#初始化元信息user_table = Table('users', meta, Column('id', Integer, primary_key=True), Column('name', String(127)), Column('fullname', String(127)), Column('password', String(127)))#创建表信息user_table.create(bind=engine)#真正创建表print (session.execute(\"select * from users;\").fetchall())#用session执行sql原生指令，fetchall()用列表返回所有结果print (session.execute(\"select * from users;\").first())#first()返回第一个结果print (session.excute(\"select * from users;\").fetchone())#fetchone()获得游标的下一个结果print (session.excute(\"select * from users;\").fetchmany(size=3))#获取size大小的结果print (session.execute('select * from users where id = :id', &#123;'id': 1&#125;).first())#这里使用变量class User(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String) fullname = Column(String) password = Column(String) def __repr__(self): return \"&lt;User(name = &#123;&#125;, fullname=&#123;&#125;, passwd=&#123;&#125;)&gt;\".format(self.name, self.fullname, self.password)ed_user = User(name = 'esd', fullname = 'Ed Jones', password = 'test')#实例化User对象session.add(ed_user)#添加session.commit()#提交query = session.query(User)for user in query: print (user.name)#查询并且便利对象数组print (session.query(User).filter_by(id = 1).first().name)print (session.query(User).filter(User.id == 1).first().name)#这两者的过滤区别主要是用法不一样print (session.query(User).get(2).name)#获取主键print (session.query(User).filter_by(id=1).scalar())#这里如果表中只有一列则返回，如果有多个列则raise错误query2 = session.query(User.name)print query2.all() # 每行是个元组print query2.limit(1).all() # 最多返回 1 条记录print query2.offset(1).all() # 从第 2 条记录开始返回print query2.order_by(User.name).all()print (query.filter_by(id = 1).update(&#123;'name':'c'&#125;))#1、更新表，需要commitquery = session.query(User)user = query.get(1)print (user.name)user.name = 'test'print (user.name)session.flush()print (user.name)#2、更新表的另外一种操作session.flush()#提交单并不真正写入数据库session.rollback()#撤销提交的内容，但是如果commit是没办法撤销的session.delete(user)#删除操作print (query.all()[0].name) 使用sqlalchemy进行join查询 session.query().join()( outerjoin())不管是join还是outerjoin他们的连接对象都是query里第一个参数所代表的表","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]},{"title":"mongodb","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/mongodb/","text":"MongoEngine 1234567from mongoengine import *connect('mydb')class User(Document): email = StringField(required = True) first_name = StringField(max_length = 50) last_name = StringField(max_length = 50) 这是一个最基本的模型，这个类就是集合的一个映射，集合的名字就是类的名字 1234567891011121314class Post(Document): title = StringField(max_length = 120, required = True) author = ReferenceField(User) tags = ListField(StringField(max_length = 30)) meta = &#123;'allow_inheritance':True&#125;class TextPost(Post): content = StringField()class ImagePost(Post): image_path = StringField()class LinkPost(Post): link_url = StringField() Post是一个基类，meta = {&#39;allow_inheritance&#39;：True}就可以被子类继承，ReferenceField是引用其他文档。 1connect(name = 'test', username = 'user', password = 1234, host = '192.168.1.35', port = 27017) 展示了connect的用法，connect类用来链接数据库。 12345678910from mongoengine.context_managers import switch_dbfrom mongoengine import *connect('myexample', alias = 'archive-user-db')class User(Document): name = StringField() meta = &#123;'db'&#125;with switch_db(User, 'archive-user-db') as User: User(name = 'Ross').save() 使用switch_db的时候，需要在connet中注册。 Field arguments db_field(Default:None) The MongoDB field name required(Default:False) 如果这个参数是True，不设置报错。 default(Default:None) 如果没有设置参数用这里面的默认值 12345678class ExampleFirst(Document): values = ListField(IntField(), default = list) #default an empty Listclass ExampleSecond(Document): values = ListFilld(IntField(), default = lambda:[1,2,3]) #default a set of valuesclass ExampleThird(Document): values = ListFilld(IntField(), default = [1,2,3]) #前面的list中append1,2,3 unique(Default : false) 当这个参数设置为True的时候，集合中的其他文档不能用同一个值 primary_key(Default:False) 当这个值为True时，用这个field作为主键 chioces(Defalut:None) 这是一个迭代器，具体用法见下面例子123SIZE = (('S','small'), ('M','medium'),('L','large'))class Shirt(Document): size = StringField(max_length = 3, chioces = SIZE) 嵌入式文档12345678class comment(EmbeddedDocument): content = StringField()class Page(Document): comments = ListField(EmbeddedDocument(comment))comment1 = comment(content = 'Good work!')comment2 = comment(content = 'NIce article!')page = Page(comments = [comment1, comment2]) mongodb允许使用嵌入式文档，具体用法见上例。 Dictionary Fields123456789class SurveyResponse(Document): date = DateTimeField() user = ReferenceField() answers = DictField()survey_response = SurveyResponse(date = datetime.now(), user = request.user)response_form = ResponseForm(response.POST)survey_response.answers = response_form.cleaned_data()survey_response.save() Reference fields123class User(Document): name = StringField() author = ReferenceField(User) 可以用来存储数据库中的其他文档 BooleanField数据库查询12for user in User.objects: print user.name 这是普通查询 1uk_users = User.objects(country = 'uk') 这是普通的条件查询，筛选出country为uk的内容 1uk_pages = Page.objects(author__country = 'uk') 查询嵌入式文档里的数据 1young_users = User.objects(age__lte = 18) 查询条件筛选，通过关键字来筛选 ne – not equal to lt – less than lte – less than or equal to gt – greater than gte – greater than or equal to not – negate a standard check in – value is in list nin – value is not in list mod-value % x == y, where x and y are two provided values all – every item in list of values provided is in array size – the size of the array is exists – value for field exists 字符串查询 exact – string field exactly matches value iexact – string field exactly matches value(case insensitive) contains – string field contains value icontains – string field contains value(case insensitive) startswith – string field starts with value istartswith – string field starts with value(case insensitive) endswith – string field ends with value iendswith – string field ends with value(case insensitive) match – performs an $elemMatch so you can match an entire document within an array 查询列表Field12class Page(Document): tags = ListField(StringField()) Page.objects(tags = &#39;coding&#39;)匹配所有字符串中里有’coding’的Page Page.objects(tags__0 = &#39;db&#39;) 通过位置来查询列表里数据 1Page.objects.fields(slice__comments=[5,10]) 如果你想只取list的一部分，可以像上面一样用slice参数 12345users = User.objects[:5]users = User.objects[5:]users = User.objects[10:15] 这里是另外一些分片操作 1234567891011121314class BlogPost(Document): title = StringField() published = BooleanField() @queryset_manager def live_posts(doc_cls, queryset): return queryset.filter(published = True)BlogPost(title = 'test1', published = True).save()BlogPost(title = 'test2', published = False).save()print len(BlogPost.objects)&gt;&gt; 2print len(BlogPost.live_posts())&gt;&gt; 1 12345678class AwesomerQuerySe(Queryset): def get_awesome(self): return self.filter(auwsome = True)class Page(Document): meta = &#123;'queryset_class':AwesomerQuerySet&#125;Page.objects.get_awesome() 这是自己定义的查询实现 12from mongoengine.queryset.visitor import Qpost.objects(Q(published = True) | (Q(publish_data__lte = datetime.now()))) 上面是条件组合查询 12345678910111213post = BlogPost(title = 'Test', page_views = 0, tags = ['database'])post.save()BlogPost.objects(id = post.id).update_one(inc_page_views = 1)post.reload()post.page_viewsBlogPost.objects(id = post.id).update_one(set__title = 'Example Post')post.reload()post.titleBlogPost.objects(id = post.id).update_one(push__tags = 'nosql') #update()是更新所有搜索到的文档post.reload()post.tags 12345678910111213141516171819202122class User(Document): name = StringField()class Page(Document): conent = StringField() authors = ListField(ReferenceField(User))bob = User(name = \"Bob Jones\").save()john = User(name = 'John Smith').save()Page(content = \"Test Page\", authors = [bob, john]).save()Page(content = \"Another Page\", authores = [john]).save()Page.objects(authors__in = [bob])#Find all page Bob authoredPage.objects(authores__all = [bob, john])#Find all pages that both Bob and John have authoredPage.objects(id = '...').update_one(pull__authors = bob)#Remove Bob from the authores for a pagePage.objects(id = '...').update_one(push__authors = john) 123456post = BlogPost(title='Test', page_views = 0, tags = ['database', 'mongo'])post.save()BlogPost.objects(id = post.id, tags = 'mongo').update(set__tags__S = 'mongodb')post.reload()print post.tags'[database, mongodb]' mongodb原生命令 db.foo.update({文档1}, {文档2}) #用文档2替换文档1 inc修改器(如果以前不存在可以创建) 1db.analytics.update(&#123;\"url\":\"www.example.com\"&#125;, &#123;\"$inc\":&#123;\"pagevies : 1\"&#125;&#125;) set修改器 1db.users.update(&#123;\"name\":\"joe\"&#125;,&#123;\"$set\":&#123;\"favorite book\":\"Green Eggs and Ham\"&#125;&#125;) uset修改器(删除掉某个键值) 1db.users.update(&#123;\"name\":\"joe\"&#125;, &#123;\"$unset\":&#123;\"favorite book\":1&#125;&#125;) push修改器(像数组里面增加东西) 1db.blog.posts.update(&#123;\"title\":\"a blog post\"&#125;, &#123;\"$push\":&#123;\"comments\":\"&#123;\"name\":\"joe\"&#125;\"&#125;&#125;) each修改器(一次向数组里面push多个值) 1db.stock.ticked.update(&#123;\"_id\":\"GOOG\"&#125;, &#123;\"$push\":&#123;\"hourly\":&#123;\"$each\":[555,444,333]&#125;&#125;&#125;) sort修改器和slice分割器 1db.movies.find(&#123;\"genre\":\"horror\"&#125;, &#123;\"$push\":&#123;\"top10\":&#123;\"$each\":[&#123;\"raings\":1&#125;,&#123;\"raings\":2&#125;], \"$slice\":-10, \"$sort\":&#123;\"ratings\":-1&#125;&#125;&#125;&#125;) slice表示只允许数组包含最后10个数组，sort表示按ratings来排序 addToSet修改器，将不重复的数据写进去1db.users.findOne(&#123;\"_id\":\"xxx\"&#125;, &#123;\"$addToSet\":&#123;\"emails\":&#123;\"$each\":[\"xxx1\", \"xxxx2\"]&#125;&#125;&#125;) $each和$addToSet结合使用可以批量添加数据 pop修改器1db.foo.update(&#123;&#125;, &#123;\"pop\":&#123;\"key\":1&#125;&#125;) 从尾部删除第一个元素，如果为-1从头部删除第一个元素 pull修改器1db.list.update(&#123;&#125;, &#123;\"$pull\":&#123;\"array\":1&#125;&#125;) pull是用来删除指定元素，pull会将文档中所有与指定相同元素删除 基于位置的数组修改器1db.blog.update(&#123;\"post\":post_id&#125;, &#123;\"$inc\":&#123;\"comments.0.votes\":1&#125;&#125;) 0代表comments数组下标下的集合 db.foo.stats() #查看填充因子 db.runCommand({“collMod”:collectionName, “usePowerOf2Sizes”:true})。该命令得到块的大小都是2的幂。会使空间利用不那么高效，但是可以使用于经常打乱的集合 upsert upsert是一种特殊的更新。要是没有找到符合更新条件的文档，就会以这个条件和更新文档为基础创建一个新文档。 1db.foo.update(&#123;\"url\":\"/blog\"&#125;,&#123;\"inc\":&#123;\"post\":1&#125;&#125;, true) update中第三个参数设置为True，表示upsert模式 更新多个文档 update只会对符合条件的第一个文档执行操作，其他文档不会进行操作。 1db.user.update(&#123;\"birthdar\":\"10/13/1978\"&#125;, &#123;\"$set\":&#123;\"gift\":\"happy birthday\"&#125;&#125;, false ,true) 将第四个参数设置为true，会更新多个文档 findAndModify findAndModify Find参数1db.user.find(&#123;&#125;,&#123;\"username\":1, \"email\":1&#125;) 只查询username和email参数。 1db.user.find(&#123;&#125;,&#123;\"fatal_weakness\":0&#125;) 删除查询结果中的某些键值对。 条件查询 $lt &lt; $lte &lt;= $gt &gt; $gte &gt;= $ne != 1db.users.find(&#123;\"age\":&#123;\"$gte\":18, \"$lt\":30&#125;&#125;) $in 1db.raffle.find(&#123;\"ticket_no\":&#123;\"$in\":[725, 542, 390]&#125;&#125;) 查找ticket_no键的值对应752.542,390的文档 $nin 1db.raffle.find(\"ticket_no\":&#123;\"$nin\":[725, 542, 390]&#125;) 返回数组中与725,542,390的值都不对应的文档 $or 1db.raffle.find(&#123;\"$or\":[&#123;\"ticket_no\":725&#125;, &#123;\"winner\":\"true\"&#125;]&#125;) 查找ticket_no为725，或者winner为true的文档 $and 1db.users.find(&#123;\"$and\":[&#123;\"x\", &#123;\"$lt\":1&#125;&#125;, &#123;\"x\":4&#125;]&#125;) null null类型不仅匹配自身，也匹配这个字段缺省的文档。 数组查询 $all 1db.foo.find(&#123;fruit:&#123;$all:[\"apple\", \"banana\"]&#125;&#125;) all用来数组查询，查询数组中既有apple，又有banana的数组。[apple,banana] $size 1db.foo.find(&#123;\"fruit\":&#123;\"$size\":3&#125;&#125;) size用来查询数组长度，上面是查询数组长度为3的数组 $slice 1234567db.blog.posts.findOne(criteria, &#123;\"comment\":&#123;\"$slice\":10&#125;&#125;)``* 只返回前十条评论* 返回一个匹配的数组元素```pythondb.blog.posts.find(&#123;\"comments.name\":\"bob\"&#125;, &#123;\"comments.$\":1&#125;) 返回名字为bob的第一个文档 数组和范围查询的相互作用 1db.test.find(&#123;\"x\":&#123;\"$gt\":10, \"$lt\":20&#125;&#125;) 这个查询数组中不仅会返回{x:15},而且会返回{x:[5,25]}，会查找小于20的数，也会查找大于10的数。不是求交集。 可以用下面方法来解决 1db.test.find(&#123;\"x\":&#123;\"$gt\":10, \"lt\":20&#125;&#125;).min(&#123;\"x\":10&#125;).max(&#123;\"x\":20&#125;) 查找大于10且小于20的数 查询内嵌文档1db.people.find(&#123;\"name.first\":\"Joe\", \"name.last\":\"Schmoe\"&#125;) 内嵌文档查询 $elemMatch 1db.blog.find(&#123;\"comments\":&#123;\"$elemMatch\":&#123;\"author\":\"joe\", \"score\":&#123;\"$gte\":5&#125;&#125;&#125;&#125;) 用了$elemMatch只返回一个内嵌文档. $where 12345db.foo.find(&#123;\"$where\":function()&#125;)&#123; for(var current in this)&#123; ... &#125;&#125; $where参数接受脚本 游标 数据库使用游标返回find的结果 1234for(i=0; i&lt;100; i++)&#123; db.collection.find()&#125;var cursor = db.collection.find() cursor.hasNext()判断数否还有结果，cursor.next()求游标下一个结果。 limit,skip,sort1db.c.find().limit(3) 最多只返回3个结果，limit()设置返回结果的上限 1db.c.find().skip(3) 跳过前3个搜索结果 1db.c.find().sort(&#123;username:1, age:-1&#125;) sort参数1代表升序，-1是降序 索引1db.users.ensureIndex(&#123;\"username\":1&#125;) 为username添加索引","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]},{"title":"标准库","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/python_lib/","text":"记录Python库的用法 itertools count1itertools.count(start= 10, step = 1)-&gt;10 ,11, 12 返回一个无限迭代器 cycle1itertools.cycle(\"abc\") -&gt;a,b,c,a,b,c 一个无限迭代器，不断循环abc的值 repeat1itertools.repeat(10, times = 3) -&gt;10,10,10 重复返回值为10的迭代器，后面为可选参数，是重复次数 chain1itertools.chain('abc', 'def') -&gt; a,b,c,d,e,f 返回一个生成器，先使用第一个迭代器中的元素，当第一个迭代器中的元素耗尽时，用第二个迭代器的元素 compress1itertools.comress('abcdef', [1,0,0,1,1,1]) 只返回与1匹配的值 dropwhile1itertools.dropwhile(lambda x:x&lt;9, [1,9,0,1]) -&gt; 9,0.1 挨个执行列表里的元素，当前面表达式为真则丢弃，直到表达式为假时，保留后面的元素 ifilter1itertools.ifilter(lambda x:x%2, range(10)) -&gt;1,3,5,7,9 筛选出是前面表达式为真的元素 ifilterfalse()1itertools.ifilterfalse(lambda x:x%2, range(10)) -&gt;0,2,4,6,8 筛选出使表达式为假的元素 islice(iterable,start,stop,step) // islice(iterable, stop) 12itertools.islice('ABCDEFG', 2) -&gt;A Bitertools.islice('ABCDEDFG'，2,4) -&gt;C D imap() 1itertools.imap(pow, (2,3,10), (5,2,3)) -&gt;32 9 100 starmap() 1itertools.starmap(pow, [(2,5), (3,2), (10,3)]) -&gt; 32, 9, 1000 takewhile() 1itertools.takewhile(lambda x:x&lt;5,[1,4,6,4,1]) -&gt;1,4 与dropwhile用法相反true的时候执行，遇到false停止 izip() 1itertools.izip('ABCD', 'xy') -&gt;Ax, By izip_longest() 1itertools.izip_longest('ABCD', 'xy', fillvalue = '-') -&gt; Ax,By,C-,D- os之file,derectories操作 os.access(path, mode)12if os.access(&quot;myfile&quot;, os.R_OK): pass 查看是否有这个文件的权限，os.F_ok(查看这个文件是否存在), os.R_ok(是否具有可读权限)，os.W_ok(是否具有可写的权限)， os.X_ok(是否具有可执行的权限) os.chdir(path) 切换工作路径至path所代表的文件夹 os.fchdir(fd) 切换工作路径至fd文件描述符所代表的文件夹 os.getcwd() 返回当期脚本的工作路径 os.getcwdu() 返回当期脚本工作路径的unicode编码 os.chroot(path) 将根目录放到当期路径上 7.os.chmod(path, mode) 改变当期文件的访问权限 不想写了，放链接 os.pathos.path os.path常用方法 系统总结一下requests库的用法12345678import requestsr = requests.get('https://api.github.com/events')r = requests.post('http://httpbin.org/post', data = &#123;'key':'values'&#125;)r = requets.put('http://httpbin.org/post', data = &#123;'key':'value'&#125;)r = requets.head('http://httpbin.org/get')r = requets.options('http://httpbin.org/get') 给URL填写查询字符串 123456789payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requets.get('http://httpbin.org/get', params = payload)print r.url #输出url&gt;&gt; http://httpbin.org/get?key2=value2&amp;key1=value1print r.text #输出text的内容print r.encoding #输出编码格式print r.content #按字节输出内容 将request的内容存储为图片 1234from PIL import Imagefrom io import BytesIOi = Image.open(BytesIO(r.content)) 将get的内容用json来编码 1234import requests&gt;&gt;&gt; r = requests.get('https://api.github.com/events')&gt;&gt;&gt; r.json() 获得从服务器发过来的socket的内容 123r = requests.get('https://api.github.com/events', stream=True)r.rawr.raw.read(20) #可选读的字节数 自定义头部 123url = 'https://api.github.com/some/endpoint'&gt;&gt;&gt; headers = &#123;'user-agent': 'my-app/0.0.1'&#125;&gt;&gt;&gt; r = requests.get(url, headers=headers) 发送文件内容 12345url = 'http://httpbin.org/post'&gt;&gt;&gt; files = &#123;'file': open('report.xls', 'rb')&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text 也可以自己content_type和文件名 12345&gt;&gt;&gt; url = 'http://httpbin.org/post'&gt;&gt;&gt; files = &#123;'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', &#123;'Expires': '0'&#125;)&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text 返回的状态码 1234567891011121314151617181920&gt;&gt;&gt; r = requests.get('http://httpbin.org/get')&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.headers&#123; 'content-encoding': 'gzip', 'transfer-encoding': 'chunked', 'connection': 'close', 'server': 'nginx/1.0.4', 'x-runtime': '148ms', 'etag': '\"e1ca502697e5c9317743dc078f67693f\"', 'content-type': 'application/json'&#125;&gt;&gt;&gt; r.headers['Content-Type']'application/json'&gt;&gt;&gt; r.headers.get('content-type')'application/json' 获取cookies 12345&gt;&gt;&gt; url = 'http://example.com/some/cookie/setting/url'&gt;&gt;&gt; r = requests.get(url)&gt;&gt;&gt; r.cookies['example_cookie_name']'example_cookie_value' 上传cookies 123456&gt;&gt;&gt; url = 'http://httpbin.org/cookies'&gt;&gt;&gt; cookies = dict(cookies_are='working')&gt;&gt;&gt; r = requests.get(url, cookies=cookies)&gt;&gt;&gt; r.text'&#123;\"cookies\": &#123;\"cookies_are\": \"working\"&#125;&#125;' 重定向 12345678910111213141516&gt;&gt;&gt; r = requests.get('http://github.com')&gt;&gt;&gt; r.url'https://github.com/'&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.history[&lt;Response [301]&gt;]&gt;&gt;&gt; r = requests.get('http://github.com', allow_redirects=False)&gt;&gt;&gt; r.status_code301&gt;&gt;&gt; r.history[] requets库的高级用法 requets高级用法 xpath的用法 XPATH 多线程threading用法 threading.activeCount()返回当期存在的线程数量 12345678mutex = threading.Lock()#锁的使用#创建锁mutex = threading.Lock()#锁定mutex.acquire([timeout])#释放mutex.release() 在锁锁定之后可以调用，mutex.wait()来阻塞，mutex.notify()来释放阻塞 1234567mutex.acquire()mutex.wait()#这里阻塞，这个方法必须在acquire之后调用，否则会报错mutex.release()mutex.acquire()mutex.notify()#这里释放阻塞，同样需要在acquire后调用mutex.release() 信号量的使用 1234567891011121314151617181920212223242526272829303132333435363738import threadingimport randomimport timeclass MyThread(threading.Thread): availableTables=['A','B','C','D','E'] def __init__(self,threadName,semaphore): self.interval =random.randrange(1,6) self.semaphore =semaphore threading.Thread.__init__(self,name=threadName) def run(self): self.semaphore.acquire() #acquire a semaphore table = MyThread.availableTables.pop() print \"%s entered;seated at table %s.\" %(self.getName(),table) time.sleep(self.interval) #free a table print \"%s exiting,freeing table %s.\" %(self.getName(),table) MyThread.availableTables.append(table) self.semaphore.release()mySemaphore = threading.Semaphore(len(MyThread.availableTables))def Test(): threads=[] for i in range(1,10): threads.append(MyThread(\"thread\"+str(i),mySemaphore)) for i in range(len(threads)): threads[i].start()if __name__ == '__main__': Test() threading.Time() 123456789\"\"\"延迟1秒执行\"\"\"import threadingdef hello(): print \"hello, world\"t = threading.Timer(1, hello)t.start() python pdb库12import pdbpdb.set_trace() 123456789101112131415161718192021222324252627282930313233h(elp) [comman] #打印可用指令及帮助信息r(eturn) #运行代码直到下一个断点或当前函数返回b(reak) [[filename:]lineno | function[, condition]] #指定文件某行或函数体来设置断点l(ist) [first[, last]] #查看指定代码段n(ext) #执行下一行s(tep) #执行下一行，若为函数则进入函数体p #打印某个变量a(rgs) #打印当前函数的参数w(here) #打印堆栈信息d(own) #移至下层堆栈u(p) #移至上层堆栈j(ump) #跳转到指定行continue / c #继续执行disable [bpnumber [bpnumber]] #失效断点enable[bpnumber [bpnumber]] #启用断点cl(ear) [filename:lineno | bpnumber [bpnumber]] #删除断点q(uit)/exit #中止调试并退出","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]},{"title":"python语法细节","date":"2017-05-06T03:48:40.000Z","path":"2017/05/06/python/","text":"这个文档用来记录python的语法细节 functools.partial1234567891011121314from functools import partialdef add(x, y): print x + yaddplus = partial(add, 3)print addplus(3)&gt;&gt; 6addplus = partial(add, 3, 4)print addplus()&gt;&gt; 7print addplus(3)#error 相当于把参数直接赋值给add函数 list list虽然简单，但用的时候老是出小问题，全面总结一下list的用法。 nums[2:5] ##下标2-5的元素，但不包括第五个元素 del[0] ##删除list中的元素 len(list) ##列表长度 list1 + list2 ##合并列表 list * 4 ##重复列表 if x in list ##True or False for x in list ## 遍历列表 list.append(obj) ##列表末尾插入 list.count(obj) ##统计某个元素出现次数 list.extend(obj) ##合并列表 list.index(obj) ##从列表中找出某个值，返回索引值 list.insert(index, obj) ##将某个值，插入列表中 list.pop() ##移除列表中的对象，并返回值。如果不填，值默认最后一个值 list.remove(obj) ##移除列表中的某个对象 list.reverse() ##倒置列表 list.sort([func]) ##列表排序 tuple cmp(tuple1, tuple2) ##比较两个元组的元素 len(tuple) ##计算元组元素个数 max(tuple) ##返回元组中元素最大值 min(tuple) ##返回元组中元素最小值 tuple(seq) ##将列表转换为元组 dict cmp(dict1, dict2) ##比较两个字典元素（键和值都要比较） len(dict) ##计算字典元素个数，键的总数 str(dict) ##将字典以字符串的形式输出打印 dic.clear() ##删除字典内的所有元素 dic.copy() ##将字典浅拷贝 dic.fromkeys(seq, [value]) ##将seq作为键，value作为值形成字典 dic.get(key, default = None) ##有对应的key则返回值，没有返回default dic.has_key() ##键在dict里面返回true,否则返回false dic.setdefault(key, default = None) 与get()类似，如果键不在字典中，将添加键值设为default dic.keys() 返回字典中所有的键 dic.values() 返回字典中所有的值 dic.items() 以可遍历的形式返回元组 dic.update(dic1) 将dic1更新到dic里面 dic.pop(object, None) 移除字典中的键的值，如果没有则返回None dic.items() 将字典按列表的形式返回 [(&#39;url&#39;, &#39;www.iplaypython.com&#39;), (&#39;title&#39;, &#39;python web site&#39;)] dic.iteritems() 字典按迭代器的形式返回 for i in dic 可以取出所有键值dict() (用来构造字典) d1 = dict(one = 1, two = 2, a = 3) d2 = dict(zip([‘one’, ‘two’, ‘three’], [1, 2, 3])) d3 = dict([(‘one’, 1), (‘two’, 2), (‘three’, 3)]) d4 = dict(d3)collections.defaultdict() 这里的defaultdict(function_factory)构建的是一个类似dictionary的对象，其中keys的值，自行确定赋值，但是values的类型，是function_factory的类实例，而且具有默认值。比如defaultdict(int)则创建一个类似dictionary对象，里面任何的values都是int的实例，而且就算是一个不存在的key, d[key] 也有一个默认值，这个默认值是int类型值0. string test1, test2 = string.split(&#39;/&#39;, 1) ##可以把值直接赋值给test1,test2 str.index(substr) ##找出子字符串在字符串的位置，返回索引值 cmp(str1,str2) ##比较字符串如果str1大返回一，相等返回0，str2返回负数 str1 and str2 ##求str1与str2的交集 str.lower() ##小写 str.upper() ##大写 str.swapcase() ##大小写互换 str.capitalize() ##首字母大写 str.count(substr) ##统计字符串在字符串中出现的次数decode、encode 在python中有两种编码方式str与unicode，str是原始字符串8位1字节，而unicode是范用的编码方式。unicode是不能进行移位操作的，要转换为str才能使用移位操作。str to unicode -&gt; str.decode(‘utf-8’)unicode to str -&gt; unicode.encode(‘utf-8’) s.endwith(&#39;substr&#39;) ##判断字符串s，是否以substr结尾 s.find(sub,[start,[,end]]) ##找出字符串中子字符串的位置，找到返回索引值，找不到返回-1 s.index(sub, [start,[,end]]) ##类似find，不过找不到报错 s.isdigit() ##判断字符串中是否全为数字 s.isalpha() ##判断字符串中是否全为字母 s.islower() ##判断字符串中是否全为小写字母，忽略数字 s.isdigit() ##判断字符串中是否全为数字 s.isspace() ##潘丹字符中是否全为空格 s.join() ##将迭代器或列表中的字符在合并在一个字符串 s.replace(old, new[, count]) ##替换字符串，如果没有count则全部替换。 __str__, __repr__123456789101112131415class example(object): def __str__(self): return ‘in_str’ def __repr__(self): return 'in_repr'exam = example()print str(exam)&gt;&gt; in_strprint repr(exam)&gt;&gt; in_reprprint exam&gt;&gt; in_str 这两个函数都是用来打印字符串，用法见上。__repr__一般用来debug，可以用eval(repr(exam))来还原。eval函数的用法是将字符串转换为表达式来计算。__repr__用’%r’来输出 __call__ 一个类中定义了call方法，则这个类形成的实例，可以像函数一样调用 __setitem__, __getitem__, __delitem__, __len__12345678910111213141516171819202122232425class MyDict(object): def __init__(self): print‘call fun __init__’ self.item = &#123;&#125; def __getitem__(self,key): print‘call fun __getItem__’ return self.item.get(key) def __setitem__(self,key,value): print‘call fun __setItem__’ self.item[key] =value def __delitem__(self,key): print‘cal fun __delitem__’ del self.item[key] def __len__(self): return len(self.item) myDict = MyDict()print myDict.itemmyDict[2] = ‘ch‘myDict['hobb'] = ‘sing’print myDict[2]print myDict.itemdel myDict[2]print myDict.itemprint len(myDict) 可以用这几个类置函数模拟字典的行为，用法见上所示 definition.__name__ 打印出类、模块、方法、生成器、函数的名字 __new__1234567891011121314151617class root(object): def __init__(self): print \"sss\" def __new__(cls, *args, **kwargs): print \"ss\" return object.__new__(cls, *args, **kwargs)class children(root): def __init__(self): print \"children\" def __new__(cls, *args, **kwargs): print \"ss1\" return root.__new__(cls, *args, **kwargs)class children1(children,root): def __init__(self): print \"children1\"obj = children1() 当一个类定义类new方法，子类再继承类这个类，那么父类的cls传入的类会是子类的类。如果不继承，那么cls传入的是自己本身。 闭包 闭包将组成函数的语句和这些语句的执行环境打包在一起，从而得到的对象。12345#foo.pyfilename = \"foo.py\"def call_func(f): return f() 123456789#func.pyimport foofilename = \"func.py\"def show_filename(): return \"filename %s\" % filenameif __name__ == \"__main__\": print foo.call_func(show_filename) 这两个函数输出的结果是func.py。闭包会捕捉内层函数所执行的整个环境。捕捉的顺序满足LEGB法则。即Local - 本地函数内部， Enclosing - 直接外围空间（如果有多层嵌套，则有内而外查找，直至找到最外层函数），Global - 全局空间，模块顶层赋值的变量，Builtin - 内置模块（builtin）预定义的变量。 装饰器1.不带参数的装饰器12345678def wrapper(func): ##接受被装饰的函数 def inner(): ##接受被装饰函数的参数 func() return inner@wrapperdef outter(): print 'i am outter' 和带参数的装饰器类似,会直接执行func的内容 2.带参数的装饰器1234567def wrapper(parameter): ##接受装饰器参数 def inner(func): ##被装饰的函 def app(): ##被装饰函数的参数 func() return app return inner return wrapper 这是带参数的装饰器，那么会直接执行里面func的内容。12345def wrapper(parameter): ##接受装饰器参数 def inner(func): ##被装饰的函 func(）##初始化的时候会执行func() return inner return wrapper 3.被装饰的对象是一个类12345678910111213def test(cls): def _test(): print cls.value print 'test' return cls ##这里如果返回cls是type类型，返回cls()是对象 return _test@testclass sy(object): value = 32obj = sy()print type(obj) test第一个参数接受一个类 123456789101112def test(cls): def _test(*args, **kwargs): print 'xxxx' return cls(*args, **kwargs) return _test@testclass sy(object): def __init__(self, value): self.value = values = sy('hello world') 第一个test接受一个类，第二个test接受类的参数 123456789101112def test(printvalue = True): def _test(cls): def __test(*args, **kwargs): print 'xxxxx' return cls(*args, **kwargs) return __testreturn _test@test(printvalue = False)class sy(object): def __init__(self, value): self.value = value 这个装饰器的使用和前面函数装饰器类似，知识第二个_test接受一个类参数 4.类式装饰器 类似装饰器本身是一个类， 借用init()和call()来实现 123456789class test(object): def __init__(self, func): self._func = func def __call__(self): return self._func()@testdef say(): return 'hello world' init中接受func参数，用call来调用 12345678class test(object): def __init__(self, func): self._func = func def __call__(self, *args, **kwargs): return self._func(*args, **kwargs)@testdef lest(str, len): call接受函数的参数 123456789101112class test(object): def __init__(self, beforeinfo = 'call function'): self.beforeinfo = beforeinfo def __call__(self, func): def _call(*args, **kwargs): print 'xxx' return func(*args, **kwargs) return __call@test('xxxx')def left(str, len): pass init装饰器的参数，call接受函数，_call接受函数的参数 123456789101112class test(object): def __init__(self, cls): self._cls = cls def __call__(self): return self.cls()@testclass sy(object): def __init__(self): self.value = 32s = sy() init接受被装饰的类本身 1234567891011class test(object): def __init__(self, printValue = False): self._printValue = printValue def __call__(self, cls): def _call(*args, **kwargs): print 'sss' return cls(*args, **kwargs) return _call@test(True)class sy(object): init接受装饰器的参数，call接受类本身， _call接受的类里初始化参数 functools.wraps12345678from functools import wrapsdef my_decorator(f): @wraps(f) def wrapper(*args, **kwargs): return f(*args, **kwargs)@my_decoratordef example(): Docstring 12345 print &apos;Called example function&apos;&gt;&gt; example.__name__&gt; &apos;example&apos;&gt;&gt; example.__doc__&gt; &apos;Docstring&apos; 如果不使用@wraps，那么example的函数的name和doc等信息将会丢失，变为wrapper函数的。 类的属性和实例的属性1234class example(object): passexample.a = 1 可以给类随意添加属性并赋值，但是如果类的属性发生变化，由类实例化的实例也会相应发生变化。 函数式编程 函数式编程，对于任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出结果 高阶函数把函数作为参数传入，这样的函数称为高阶函数。 Map函数 12345def f(x): return x*xmap(f, [1,2,3,4,5,6])[2,4,9,16,25,36] 把列表里的值带入f()函数一个一个算 Reduce函数 1234def fn(x,y): return x*10+yprint reduce(fn, [1,3,5,7,9])&gt;&gt;13579 类似于迭代把前面算出来的值，作为参数与后面的值一起计算。 type和object的关系 这个知识点很重要的参考这篇文章 urllib、urllib2 urllib.unquote(string)将十六进制转换为它们对应的字符，用于url编码格式 ‘enter‘ and ‘exit‘123456789101112131415161718192021222324252627282930class WithDemo(object): def __init__(self, name): self.name = name def __enter__(self): print 'enter:' + self.name return self def __exit__(self, exc_type, exc_val, exc_tb): print 'in:' + self.name print \"type:\", exc_type print \"value:\", exc_val print \"trace:\", exc_tb def do_something(self): bar = 1 / 0 return bar + 10with WithDemo('changshuhang') as w: # print w # w.do_something() print w&gt;&gt; enter:changshuhang&gt;&gt; &lt;__main__.WithDemo object at 0x7f8e044e5410&gt;&gt;&gt; in:changshuhang&gt;&gt; type: None&gt;&gt; value: None&gt;&gt; trace: None enter, exit,当使用with语句的时候触发 python搜索路径 Python 搜索路径 就是使用 import 语句时，Python 所查找的系统目录清单。 举例来说，假定你将 Python 路径设置为 [‘’,’/usr/lib/python2.4/site-packages’,’/home/username/djcode/‘] 。如果执行代码 from foo import bar ，Python 将会首先在当前目录查找 foo.py 模块( Python 路径第一项的空字符串表示当前目录)。 如果文件不存在，Python将查找 /usr/lib/python2.4/site-packages/foo.py 文件。 getattr(), hasattr() 这两个函数可以获取类或实例的方法和属性","tags":[{"name":"编程,笔记","slug":"编程-笔记","permalink":"http://yoursite.com/tags/编程-笔记/"}]}]